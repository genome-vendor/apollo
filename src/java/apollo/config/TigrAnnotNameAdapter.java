package apollo.config;

import org.apache.log4j.*;

import apollo.datamodel.*;

import apollo.editor.AddTransaction;
import apollo.editor.CompoundTransaction;
import apollo.editor.Transaction;
import apollo.editor.TransactionManager;
import apollo.editor.TransactionSubpart;
import apollo.editor.UpdateTransaction;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.lang.Runtime;
import java.util.Vector;
import java.util.regex.Pattern; 
import java.util.regex.Matcher;
import apollo.dataadapter.ApolloDataAdapterI;
// TODO - resolve the following questions
//  -what is the role of the transaction-generating methods in this class?  are these needed?
//  -should this class have "chado" somewhere in the title...it's clearly somewhat chado-specific

/**
 * Name adapter for TIGR chado annotation databases.  This class currently
 * invokes an external application (the ergatis IdGenerator.pm module) to
 * generate unique ids for rows to be inserted into a given TIGR database.
 * This is not the fastest approach but it should be adequate for interactive
 * use in Apollo.
 *
 * In the TIGR chado annotation databases we'll be using the chado 
 * feature.uniquename as both the feature id and the feature name in Apollo
 * (i.e., the values returned by generateName() and generateId().  These
 * uniquenames (by convention) look like this:
 *
 * eha3.gene.1234.1
 *
 * i.e., <chado database name>.<chado SO type>.<unique id>.<version number>
 *
 * The chado SO type may be abbreviated and the <unique id> is unique only
 * with respect to the name database and SO type.  If a feature is modified
 * then the resulting feature will have the same uniquename, but with the
 * final <version number> component of the uniquename incremented.
 *
 * TODO - add link to detailed specification document
 *
 * @version $Revision: 1.9 $ $Date: 2007/04/20 19:44:27 $ $Author: jcrabtree $
 */
public class TigrAnnotNameAdapter implements ApolloNameAdapterI {

  // -----------------------------------------------------------------------
  // Class variables
  // -----------------------------------------------------------------------

  protected final static Logger logger = LogManager.getLogger(TigrAnnotNameAdapter.class);

  /**
   * Path to a program or script that accepts two arguments on the command line:
   *  1. the name of a chado database
   *  2. the name of a chado feature type
   *
   * When provided with these two arguments the program should return a new 
   * chado uniquename (of the form 'db.feat.idnum.vernum') on stdout.
   */
  protected static String newNameCommand = Config.getTigrAnnotNameAdapterNewNameCommand();

  // -----------------------------------------------------------------------
  // Instance variables
  // -----------------------------------------------------------------------

  protected TransactionManager transactionManager;
  // check that a chado uniquename adheres to our naming convention ("dbname.sotype.id.ver")
  protected Pattern validIdPattern = Pattern.compile("^([a-z\\d]+)\\.([a-z]+)\\.(\\d+)\\.(\\d+)$");
  // prefix of the curation name should be the chado uniquename of the sequence in question
  protected Pattern validCurationNamePattern = Pattern.compile("^([a-z\\d]+)\\.([a-z]+)\\.(\\d+)\\.(\\d+)");
  // used to track all *new* feature names generated by the instance
  protected HashMap featToName = new HashMap();
  // used to track all *new* feature ids generated by the instance
  protected HashMap featToId = new HashMap();

  // -----------------------------------------------------------------------
  // Constructor
  // -----------------------------------------------------------------------
  
  public TigrAnnotNameAdapter() {}
  
  // -----------------------------------------------------------------------
  // ApolloNameAdapterI
  // -----------------------------------------------------------------------

  public String generateName(StrandedFeatureSetI annots, String curation_name, SeqFeatureI feature) 
  {
    return this.generateName(annots, curation_name, feature, true);
  }

  // JC - this method only appears to be used in SimpleNameAdapter, to assign a feature a
  // name based on the first feature in <code>exonResults</code>
  public String generateName(StrandedFeatureSetI annots, String curation_name, SeqFeatureI feature, 
                             Vector exonResults) 
  {
    return generateName(annots, curation_name, feature); // ignore exonResults
  }

  public String generateId(StrandedFeatureSetI annots, String curation_name, SeqFeatureI feature) 
  {
    return this.generateId(annots, curation_name, feature, true);
  }

  public String generateNewId(StrandedFeatureSetI annots, String curation_name, SeqFeatureI feature) 
  {
    return this.generateId(annots, curation_name, feature, false);
  }

  public String generateExonId(StrandedFeatureSetI annots, String curation_name, SeqFeatureI exon, String geneId)
  {
    return generateId(annots, curation_name, exon, true);
  }

  public String generateNewExonId(StrandedFeatureSetI annots, String curation_name, SeqFeatureI exon, String geneId)
  {
    return generateId(annots, curation_name, exon, false);
  }

  public void updateExonId(ExonI exon) {
    // NO-OP - exon ids don't depend on their coordinates in the TIGR chado annotation dbs
  }

  // Called by AnnotationEditor to generate a name for the new gene in a SPLIT transaction
  public String generateAnnotSplitName(SeqFeatureI annot, StrandedFeatureSetI annotParent, String curationName) 
  {
    logger.trace("generateAnnotSplitName called on annot=" + annot + ", parent=" + annotParent + " curation=" + curationName);
    // force the generation of a *new* name:
    return generateName(annotParent,curationName,annot,false);
  }

  // ADDED by TAIR
  public String getSuffixDelimiter() {
    throw new UnsupportedOperationException();
  }

  public boolean checkName(String name, Class featureClass) 
  {
    throw new UnsupportedOperationException();
  }

  public CompoundTransaction setAnnotName(AnnotatedFeatureI annot,
                                          String newName)
  {
    throw new UnsupportedOperationException();
  }

  // HACK - copied this from DefaultNameAdapter
  protected UpdateTransaction setName(AnnotatedFeatureI annFeat, String newName) {
    TransactionSubpart ts = TransactionSubpart.NAME;
    UpdateTransaction ut = new UpdateTransaction(annFeat,ts,annFeat.getName(),newName);
    ut.editModel();
    return ut;
  }

  public CompoundTransaction setTranscriptName(AnnotatedFeatureI trans,
                                               String name)
  {
    // TODO - copied this verbatim from DefaultNameAdapter
    String oldName = trans.getName(); // before edit
    CompoundTransaction ct = new CompoundTransaction(this);
    UpdateTransaction ut = setName(trans,name);
    ct.addTransaction(ut);
    return ct;
  }

  public CompoundTransaction setTranscriptId(SeqFeatureI trans, 
                                             String id) 
  {
    // TODO - copied this verbatim from DefaultNameAdapter
    CompoundTransaction ct = new CompoundTransaction(this);
    ct.addTransaction(setId(trans,id));
    return ct;
  }

  protected UpdateTransaction setId(SeqFeatureI annot, String newId) {
    // TODO - copied this verbatim from DefaultNameAdapter
    TransactionSubpart ts = TransactionSubpart.ID;
    String oldId = annot.getId();
    UpdateTransaction ut = new UpdateTransaction(annot,ts,oldId,newId);
    ut.setOldId(oldId);
    ut.setNewId(newId);
    ut.editModel(); // makes change to annot
    return ut;
  }

  public CompoundTransaction setTranscriptNameFromAnnot(AnnotatedFeatureI transcript,
                                                        AnnotatedFeatureI gene) 
  {
    throw new UnsupportedOperationException();
  }

  public boolean nameIsId (SeqFeatureI feature) 
  {
    String featId = feature.getId();
    String featName = feature.getName();
    logger.trace("nameIsId called for feature with id=" + featId + " name=" + featName);
    return isValidFeatureUniquename(featName, feature);
  }

  public boolean suffixInUse(Vector transcripts, String suffix, int t_index)
  {
    throw new UnsupportedOperationException();
  }

  public boolean checkFormat(SeqFeatureI feat,String id) {
    throw new UnsupportedOperationException();
  }

  public boolean idAndNameHaveSameFormat(SeqFeatureI feat,String id, String name) { 
    throw new UnsupportedOperationException();
  }


  public String getTranscriptNamePattern() {
    throw new UnsupportedOperationException();
  }

  public boolean typeChangeCausesIdChange(String oldType, String newType) {
    throw new UnsupportedOperationException();
  }

  public String getNewIdFromTypeChange(String oldId,String oldType,String newType) {
    throw new UnsupportedOperationException();
  }

  public void setTransactionManager(TransactionManager tm) {
    this.transactionManager = transactionManager;
  }

  public CompoundTransaction setAnnotId(AnnotatedFeatureI annot, String id) {
    throw new UnsupportedOperationException();
  }

  public boolean isTemp(String idOrName) {
    // this name adapter does not generate temporary ids:
    return false;
  }

  // TODO - the implementations of these methods are a little misleading, because they 
  // will each generate a *new* id each time, without really using the referenced id
  // or name.

  public String generatePeptideNameFromTranscriptName(String transcriptName) {
    String chadoDb = parseChadoDbFromFeatureName(transcriptName);
    return generateNewChadoFeatureUniquename(chadoDb, "polypeptide");
  }

  public String generatePeptideIdFromTranscriptId(String transcriptId) {
    return generatePeptideNameFromTranscriptName(transcriptId);
  }

  public String generateChadoCdsNameFromTranscriptName(String transcriptName) {
    String chadoDb = parseChadoDbFromFeatureName(transcriptName);
    return generateNewChadoFeatureUniquename(chadoDb, "CDS");
  }

  public String generateChadoCdsIdFromTranscriptId(String transcriptId) {
    return generateChadoCdsNameFromTranscriptName(transcriptId);
  }

  // -----------------------------------------------------------------------
  // TigrAnnotNameAdapter - protected methods
  // -----------------------------------------------------------------------

  /**
   * @param useAnyValidId If true and the feature has a valid chado id then that id will be returned.
   */
  protected String generateId(StrandedFeatureSetI annots, String curation_name, SeqFeatureI feature, 
			      boolean useAnyValidId)
  {
    String featName = feature.getName();
    String featId = feature.getId();
    String prevId = getIdGeneratedForFeature(feature);
    String prevName = getNameGeneratedForFeature(feature);

    if (logger.isTraceEnabled()) {
      logger.trace("generateId() called on feature with id = " + featId + ", name = " + featName +
		   ", topLevelType = " + feature.getTopLevelType() + ", programName = " + feature.getProgramName() +
		   ", parent = " + feature.getParent());
      logger.trace("prevId for " + feature + " = " + prevId + " prevName = " + prevName);
    }

    // case 1: any valid chado id is acceptable
    if (useAnyValidId && isValidFeatureUniquename(featId, feature)) {
      logger.trace("==== generateName: case 1: " + " id=" + featId + " name=" + featName + " result=" + featId);
      return featId;
    }

    // case 2: we have previously generated a name for this feature
    if ((featName != null) && (prevName != null) && (featName.equals(prevName)) &&
	((featId == null) || (!featId.equals(featName)))) {
      logger.trace("==== generateName: case 2: " + " id=" + featId + " name=" + featName + " result=" + featName);
      return featName;
    }

    // case 3: none of the above applies
    String newName = generateNewChadoFeatureUniquename(curation_name, feature);

    logger.trace("generateId(" + feature.getClass() + ") returning " + newName + 
                 " for feature with id=" + feature.getId() + " and name=" + feature.getName());

    recordIdForFeature(feature, newName);
    logger.trace("==== generateName: case 3: " + " id=" + featId + " name=" + featName + " result=" + newName);
    return newName;
  }

  /**
   * @param useAnyValidName If true and the feature has a valid chado id then that id will be returned.
   */
  protected String generateName(StrandedFeatureSetI annots, String curation_name, SeqFeatureI feature, 
				boolean useAnyValidName)
  {
    String featId = feature.getId();
    String featName = feature.getName();

    String prevId = getIdGeneratedForFeature(feature);
    String prevName = getNameGeneratedForFeature(feature);

    if (logger.isTraceEnabled()) {
      logger.trace("generateName() called on feature with id = " + featId + ", name = " + featName +
		   ", topLevelType = " + feature.getTopLevelType() + ", programName = " + feature.getProgramName() +
		   ", parent = " + feature.getParent());
      logger.trace("prevId for " + feature + " = " + prevId + " prevName = " + prevName);
    }

    // case 1: any valid chado id is acceptable
    if (useAnyValidName && isValidFeatureUniquename(featName, feature)) {
      logger.trace("==== generateName: case 2: " + " id=" + featId + " name=" + featName + " result=" + featName);
      return featName;
    }

    // case 2: we have previously generated an id for this feature
    if ((featId != null) && (prevId != null) && (featId.equals(prevId)) && 
	((featName == null) || (!featName.equals(featId)))) {
      // use the id as the name also
      logger.trace("==== generateName: case 3: " + " id=" + featId + " name=" + featName + " result=" + featId);
      return featId;
    }

    // case 3: none of the above applies
    String newName = generateNewChadoFeatureUniquename(curation_name, feature);

    logger.trace("generateName(" + feature.getClass() + ") returning " + newName + 
                 " for feature with id=" + featId + " and name=" + feature.getName());

    recordNameForFeature(feature, newName);
    logger.trace("==== generateName: case 4: " + " id=" + featId + " name=" + featName + " result=" + newName);
    return newName;
  }

  /**
   * Tests whether a given string adheres to the TIGR naming convention.
   */
  protected boolean isValidFeatureUniquename(String name) {
    if (name == null) return false;
    Matcher m = validIdPattern.matcher(name);
    return m.matches();
  }

  /**
   * A more stringent version of <code>isValidFeatureUniquename</code> that takes the type of
   * feature into account.
   */
  protected boolean isValidFeatureUniquename(String name, SeqFeatureI feature) {
    if (!isValidFeatureUniquename(name)) return false;

    // check that name/id contains the abbreviated SO type, as per the TIGR naming convention
    String soType = getAbbreviatedSOTypeForFeature(feature);
    return (name.indexOf("." + soType + ".") != -1);
  }

  /**
   * Assumes a curationName of the form "eia1.assembly.502.1"
   */
  protected String parseChadoDbFromCurationName(String curationName) {
    Matcher m = validCurationNamePattern.matcher(curationName);
    if (!m.matches()) {
      throw new IllegalArgumentException("curation_name " + curationName + " does not follow TIGR annotation db naming convention");
    }
    return m.group(1);
  }

  /**
   * Assumes a feature uniquename of the form "eia1.exon.1234.3"
   */
  protected String parseChadoDbFromFeatureName(String featureName) {
    Matcher m = validIdPattern.matcher(featureName);
    if (!m.matches()) {
      throw new IllegalArgumentException("feature name " + featureName + " does not follow TIGR annotation db naming convention");
    }
    return m.group(1);
  }

  /**
   * Determine the (sometimes abbreviated) SO type used in TIGR annotation database uniquenames/ids
   */
  protected String getAbbreviatedSOTypeForFeature(SeqFeatureI feature) {
    String type = null;

    if (feature instanceof Protein) {
      type = "polypeptide";
    } 
    else if (feature instanceof ExonI) {
      type = "exon";
    } 
    else if (feature instanceof Transcript) {
      type = "transcript";
    } 
    else if (feature instanceof AnnotatedFeature) {
      if (feature.isProteinCodingGene()) {
        type = "gene";
      } 

      // TODO - handle transposable_elements gracefully, since these appear in the "create annotation" menu

      else {
        throw new UnsupportedOperationException("getAbbreviatedSOTypeForFeature() called on an AnnotatedFeature of unrecognized type: "  + feature);
      }
      // TODO - check other possibilities here?
    }
    else {
      throw new UnsupportedOperationException("getAbbreviatedSOTypeForFeature() called on a SeqFeatureI of unrecognized type: "  + feature);
    }

    return type;
  }

  /**
   * Generate a new chado feature uniquename using <code>newNameCommand</code> and
   * the specified chado database and feature type.
   *
   * @param chadoDb Name of the chado database into which the feature will be inserted.
   * @param featType (Abbreviated SO) type of the feature.
   */
  protected String generateNewChadoFeatureUniquename(String chadoDb, String featType)
  {
    Runtime r = java.lang.Runtime.getRuntime();
    String newName = "naming_error";

    if (newNameCommand == null) {
      logger.error("no name/id generator defined; check that TigrAnnotNameAdapterNewNameCommand is correctly set in apollo.cfg");
      return null;
    }

    logger.trace("TigrAnnotNameAdapter: invoking " + newNameCommand + " " + chadoDb + " " + featType);

    try {
      Process p = r.exec(new String[] {newNameCommand, chadoDb, featType});
      InputStream p_in = p.getInputStream();
      BufferedReader br = new BufferedReader(new InputStreamReader(p_in));
      newName = br.readLine();

      // check that the end of stdout has been reached
      String output = br.readLine();
      if (output != null) {
        logger.error("TigrAnnotNameAdapter: unexpected response from newNameCommand - " + output);
      }

      int retval = p.waitFor();
      // check that return value indicates normal termination (0 for unix)
      if (retval != 0) {
        logger.error("TigrAnnotNameAdapter: unexpected return code (" + retval +") from the following command: " + 
                     newNameCommand + " " + chadoDb + " " + featType);
      }
    } 
    catch (java.io.IOException ioe) {
      logger.error("IOException in generateNewFeatureName", ioe);
    }
    catch (java.lang.InterruptedException ie) {
      logger.error("InterruptedException in generateNewFeatureName", ie);
    }

    return newName;
  }

  /**
   * Generate a new chado feature uniquename for the specified curation set and Apollo feature.
   */
  protected String generateNewChadoFeatureUniquename(String curationName, SeqFeatureI feature) 
  {
    String chadoDb = parseChadoDbFromCurationName(curationName);
    String featType = getAbbreviatedSOTypeForFeature(feature);
    return generateNewChadoFeatureUniquename(chadoDb, featType);
  }
  public void setDataAdapter(ApolloDataAdapterI dataAdapter) {}

  /**
   * Remember the id generated for a feature.
   */
  protected void recordIdForFeature(SeqFeatureI feature, String id) {
    featToId.put(feature, id);
  }

  /**
   * @return The id (if any) that was previously generated for the specified feature.
   */
  protected String getIdGeneratedForFeature(SeqFeatureI feature) {
    if (logger.isTraceEnabled()) {
      Iterator i = featToId.keySet().iterator();
      while (i.hasNext()) {
	SeqFeatureI n = (SeqFeatureI)i.next();
      }
    }

    return (String)(featToId.get(feature));
  }

  /**
   * Remember the name generated for a feature.
   */
  protected void recordNameForFeature(SeqFeatureI feature, String name) {
    featToName.put(feature, name);
  }

  /**
   * @return The name (if any) that was previously generated for the specified feature.
   */
  protected String getNameGeneratedForFeature(SeqFeatureI feature) {
    if (logger.isTraceEnabled()) {
      Iterator i = featToId.keySet().iterator();
      while (i.hasNext()) {
	SeqFeatureI n = (SeqFeatureI)i.next();
      }
    }
    return (String)(featToName.get(feature));
  }
  

}
